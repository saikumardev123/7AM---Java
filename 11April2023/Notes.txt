SortedSet: 

The SortedSet is the child of Set interface and the implementation class of 
SortedSet is TreeSet.

If we want to have an order - ascending / descending order of items, then 
we can use TreeSet.

TreeSet allows only one type of items because sorting can be done with similar
type of items only.

import java.util.TreeSet;

public class TreeSetDemo {
	
	public static void main(String[] args) {
		
	      TreeSet<Integer> treeSet = new TreeSet<Integer>();	
	      treeSet.add(899);
	      treeSet.add(22);
	      treeSet.add(123);
	      treeSet.add(8);
	      treeSet.add(1);
	      treeSet.add(6);
	      treeSet.add(80);
	      System.out.println(treeSet);
	      
	      // Incase if we want descending / any other order, we need to customize TreeSet using Comparator
	      
		/*
		 *   Task:  Create a class that implement Comparator and provide the implementation to get the descending order.
		 * 
		 * 
		 */
	}

}

List: The implementation classes of List are ArrayList and Vector. 
import java.util.ArrayList;

public class ArrayListDemo {
	public static void main(String[] args) {
		
		ArrayList<Object> al = new ArrayList<Object>();
		al.add(10);
		al.add("hello");
		al.add(10);
		al.add(10);
		al.add(10);
		al.add(true);
		System.out.println(al);
		System.out.println(al.get(0));
		System.out.println(al.get(1));
		al.remove(2);
		al.remove(2);
		al.remove(2);
		al.add(2, "hey");
		System.out.println(al);
		
		/*
		 * 
		 *  Insertion order is guranteed
		 *  duplicate values allowed
		 *  it is a dynamic array
		 *  methods to perform the operations on ArrayList
		 * methods of AL are not synchronized 
		 */
		
	}

}

Vector:

import java.util.ArrayList;
import java.util.Vector;

public class VectorDemo {
	public static void main(String[] args) {
		
		Vector<Object> al = new Vector<Object>();
		al.add(10);
		al.add("hello");
		al.add(10);
		al.add(10);
		al.add(10);
		al.add(true);
		System.out.println(al);
		System.out.println(al.get(0));
		System.out.println(al.get(1));
		al.remove(2);
		al.remove(2);
		al.remove(2);
		al.add(2, "hey");
		System.out.println(al);
		
		/*
		 * 
		 *  Insertion order is guranteed
		 *  duplicate values allowed
		 *  it is a dynamic array
		 *  methods to perform the operations on Vector
		 *  Vector methods are synchronized (thread safe)
		 * 
		 */
		
	}

}

Cheat Sheet -> https://javaconceptoftheday.com/java-collections-cheat-sheet/ 

Map Interface: 

implementation classes are HashMap and LinkedHashMap.

HashMap:

/*

  1. insertion order is not guranteed. 
  2. data will be stored in key/value pairs. 
  3.provides different methods to work up on HashMapped values.

*/

import java.util.HashMap;

public class HashMapDemo {
	public static void main(String[] args) {
       	HashMap<Integer,String> hm = new HashMap<Integer, String>();
		 hm.put(104, "Anil");
		 hm.put(105, "Naveen");
		 hm.put(101, "Kiran");
		 hm.put(102, "Rajesh");
		 hm.put(103, "Nikhil");
		 System.out.println(hm);
		 System.out.println(hm.get(104));
		
	}
}




LinkedHashMap:

/*

  1. insertion order is  guranteed. 
  2. data will be stored in key/value pairs. 
  3.provides different methods to work up on HashMapped values.

*/


import java.util.LinkedHashMap;

public class LinkedHashMapDemo {
	public static void main(String[] args) {
		LinkedHashMap<Integer,String> hm = new LinkedHashMap<Integer, String>();
		
		 hm.put(105, "Naveen");
		 hm.put(101, "Kiran");
		 hm.put(104, "Anil");
		 hm.put(102, "Rajesh");
		 hm.put(103, "Nikhil");
		 System.out.println(hm);
		 System.out.println(hm.get(104));
		
	}
}


HashTable:

HashTable is same as HashMap however the difference is, HashTable is 
synchronized, where as HashMap is not synchronized.

import java.util.Hashtable;

public class HashTableDemo {
	public static void main(String[] args) {
		Hashtable<Integer,String> hm = new Hashtable<Integer, String>();
		
		 hm.put(105, "Naveen");
		 hm.put(101, "Kiran");
		 hm.put(104, "Anil");
		 hm.put(102, "Rajesh");
		 hm.put(103, "Nikhil");
		 System.out.println(hm);
		 System.out.println(hm.get(104));
		
	}
}

PS: Create / Store a list of bank customers. 







