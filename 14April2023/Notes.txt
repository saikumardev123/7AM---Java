JVM: Java Virtual Machine 

JVM is to run the byte code generated by the compiler and also provide the 
memory allocation for the code.

java <classname> - JVM gets loaded and starts loading java class and perform 
memory allocation.

Class Loader: 
The main use of class loader is to load the .class file and cross check if 
byte code is valid based on the instructions. 

Some realtime issues:  
if a java class is compiled by version 17 and run in version 8, then the class loader 
will raise an error w.r.t version mismatch.

once the class loader loads the class (byte code) successfully then the memory 
allocation gets started. 


There are 5 different memory areas for memory allocation. 

1. Class Area  / Static Area : class related resources will be stored in 
class area. static variables, static methods, static classes will be stored 
in class area.

2.Heap : All the java objects will be stored under heap area. 
   
     for string literals, a new memory location (String Constant Pool) is created 
     under Heap area. 
      In SCP, The string objects which are created without using new keyword will 
      be stored. 
      ex:  String str="hello";

3. Stack :  Stack is responsible for storing the current execution related 
functions / methods and its local variables.

 Stack plays an important role in execution of the methods.


      class A{

             void m1(){
                m2();
             }
             void m2(){
               m3();
             }
             void m3(){

             }
            public static void main(String args[]){
                   m1();
             }

      }

       // m1(), m2(), m3(), main()

       Stack (LIFO) -   main()         main(), m1()     main(),m1(),m2()        main(),m1(),m2(),m3()

                                                                                            
4.PC Register: PC Register is responsible to store the addresses of the operations

5. Native Method Stack:  If we use C/C++ related methods/ functions in java,then those functions gets 
stored in Native Method Stack.


Execution Engine: 

The execution of byte code is done using Interpreter. 

Interpreter is slow in execution. To accelerate the execution process, a compiler called JIT(Just In Time) is 
introduced.

So, Interpreter and JIT compiler executes the code hand in hand. 

Interpreter exeuctes non-iteratable code.  It is used to execute sequential statements.

JIT compiler executes iterable statements.


JNI (Java Native Interface) is responsible for running the native methods. 


     function f1(a){

     }

     f1(function(){

     }); //


Java 8 Features: 

Functional interface:


@FunctionalInterface
interface Login{
	  boolean authenicate(String username, String password);
}


public class FI {

	public static void main(String[] args) {
		
		Login login= (String username, String password) ->  username.contentEquals("sai") && password.contentEquals("sai");
	
		
		System.out.println(login.authenicate("sa4i", "sai"));
		
	}
	
}







